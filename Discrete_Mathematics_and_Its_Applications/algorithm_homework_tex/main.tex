% https://tex.stackexchange.com/a/145660/308105 https://latex.org/forum/viewtopic.php?p=51656#p51656 to use "\setlength{\mathindent}{0pt}"
\documentclass{article}
\usepackage{graphicx} 
\usepackage{amsmath}
\usepackage[noend,ruled,lined]{algorithm2e}
\usepackage{mathtools}
\usepackage{mfirstuc}
\usepackage{enumitem}
\usepackage{pifont,amssymb}
\usepackage{float}

\usepackage[normalem]{ulem}
% \usepackage{enumitem}
% https://texblog.org/2012/03/21/cross-referencing-list-items/
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother

\usepackage[nodisplayskipstretch]{setspace} % for "\setstretch" macro

% \usepackage[normalem]{ulem}

% https://www.overleaf.com/learn/latex/Hyperlinks#Reference_guide to use ref link
% https://tex.stackexchange.com/a/82913/308105
% TODO cleveref https://tex.stackexchange.com/questions/83037/difference-between-ref-varioref-and-cleveref-decision-for-a-thesis
\usepackage{hyperref}
% https://www.overleaf.com/learn/latex/Using_colours_in_LaTeX
\usepackage[dvipsnames]{xcolor}
\definecolor{DarkGreen}{HTML}{077F37}
\hypersetup{
    colorlinks=true,
    linkcolor=DarkGreen,
    filecolor=magenta,
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }
% https://tex.stackexchange.com/a/39228/308105
\usepackage{indentfirst}

\makeatletter
\setlength{\@fptop}{0pt}
\setlength{\@fpsep}{3pt}
\setlength{\@fpbot}{0pt plus 1fil}
\makeatother

% https://www.overleaf.com/learn/latex/Page_size_and_margins#Paper_size,_orientation_and_margins
% \usepackage{layout}
% \setlength{\hoffset}{0pt}
% \setlength{\oddsidemargin}{0pt}
% \setlength{\marginparsep}{0pt}
% \setlength{\textwidth}{500pt}
% https://tex.stackexchange.com/a/367867/308105
\usepackage[left=0.3in,textwidth=7.3in,top=0.3in,bottom=0.3in]{geometry}

\newlist{todolist}{enumerate}{2}
% https://www.tug.org/TUGboat/tb09-1/tb20bechtolsheim.pdf
\setlist[todolist]{label={\arabic*.\makebox[0pt][r]{\noexpand\emptysquare\hspace{1.3em}}},ref=\arabic*}

% https://tex.stackexchange.com/a/138996/308105
\usepackage{etoolbox,setspace}
% \AtBeginEnvironment{algorithm}{\setstretch{20.5}}
\setstretch{1.2}

\newcommand{\emptysquare}{$\square$}
\newcommand{\checkedsquare}{\makebox[0pt][l]{\raisebox{1pt}[0pt][0pt]{\large\hspace{1pt}\cmark}}$\square$}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\correctanswer}{{\renewcommand{\emptysquare}{\checkedsquare}\item\leavevmode}}

% https://tex.stackexchange.com/a/20613/308105
% here 0 is one renaming for one box https://tex.stackexchange.com/a/46483/308105
% \rule https://en.wikibooks.org/wiki/LaTeX/Rules_and_Struts
% \wd https://tex.stackexchange.com/a/222617/308105
% \rlap https://www.tutorialspoint.com/tex_commands/rlap.htm https://tex.stackexchange.com/a/146100/308105
% \ht https://tex.stackexchange.com/a/258779/308105
\newcommand\hcancel[2][black]{\setbox0=\hbox{$#2$}%
\rlap{\raisebox{.45\ht0}{\textcolor{#1}{\rule{\wd0}{1pt}}}}{#2}} 

% \setlength{\mathindent}{0pt}

% https://www.overleaf.com/learn/latex/%5Chfuzz this doesn't influence the typesetting https://tex.stackexchange.com/a/50850/308105
\hfuzz=500pt
\hbadness=99999

% https://tex.stackexchange.com/a/169711/308105
% \renewcommand{\topfraction}{.5}
% \renewcommand{\floatpagefraction}{.75}
% https://www.overleaf.com/learn/latex/Environments#Defining_simple_environments and https://tex.stackexchange.com/a/67849/308105
\newenvironment{SpacingAlgorithm}[2]{
% this will make the figures more condensed https://tex.stackexchange.com/a/35130/308105
% \nopagebreak may not influence this
% TODO see this https://tex.stackexchange.com/a/2282/308105, https://tex.stackexchange.com/questions/701558/how-to-make-the-multiple-floating-blocks-not-occupying-the-whole-page-while-keep?noredirect=1#comment1744632_701558 to think of one better solution
% with the \par, then no need for the preceding "\\" to separate it from others.
    \par\addvspace{10pt}
    \begin{algorithm}[H]
    % \begin{algorithm}[htb]
        \setstretch{1.10}
        \caption{#1}\label{alg:#2}
}
{
% https://tex.stackexchange.com/a/701544/308105
    \end{algorithm}
    \vspace{10pt}
}
\setlist{nolistsep}

% https://tex.stackexchange.com/q/701531/308105
\makeatletter
\newenvironment{shiftedflalign*}{%
    \vspace{-10pt}
    \start@align\tw@\st@rredtrue\m@ne
    % \hspace{-7pt}
}{%
    \endalign
    \vspace{-40pt}
}
\makeatother

% https://tex.stackexchange.com/a/701546/308105
\newenvironment{shiftedalign*}[1][5pt]{%
  \par\vspace{0ex}% adjust
  % \hspace{#1}%
  $\begin{aligned}%
}{%
  \end{aligned}$
  \par\vspace{+1ex}% adjust
}

% https://tex.stackexchange.com/a/234320/308105
% here should use \def https://tex.stackexchange.com/a/262/308105
\edef\mylb{\\}
% \def\mylb{\newline}
\newcommand{\CondensedNewline}{\mylb[-0.5em]}

% https://tex.stackexchange.com/questions/518403/how-to-use-newenvironment-and-align-in-standalone-document#comment1311023_518403
\newenvironment{CondensedAlign}{%

% % the \\ redefinition will make \begin{cases} fail which is weird.
% \let\mylb\\
% \renewcommand{\\}{\mylb[-0.1cm]}

% % https://tex.stackexchange.com/a/234320/308105 TODO why this only takes effects in align
% \let\myhalign\halign
% \def\halign{%
% \let\mylb\\
% \renewcommand{\\}{\mylb[-0.1cm]}
% \myhalign
% }

% only valid for cases* by the mathtools package which also allows for & https://tex.stackexchange.com/a/14680/308105
\addtolength{\jot}{-5pt}

  \par\vspace{0ex}% adjust
  $\displaystyle\aligned
}{
  \endaligned$
  \par\vspace{+1ex}% adjust
  \renewcommand{\\}{\mylb}
}

\newenvironment{CondensedCases}{%

% these don't work for the cases block
% \let\mylb\\
% \renewcommand{\\}{\mylb[1cm]}

% \let\myhalign\hhalign
% % notice here def can't be same as above halign, otherwise many weird errors.
% \gdef\hhalign{%
% \let\mylb\\
% \renewcommand{\\}{\mylb[40cm]}
% \myhalign
% }

% https://tex.stackexchange.com/a/472518/308105 doesn't work for the inline mode, although warning "Command \normalsize invalid in math mode.".
\everydisplay=\expandafter{\the\everydisplay\setstretch{0.9}}

  \par\vspace{-5ex}% adjust
  % $\displaystyle\begin{cases}
  $$\displaystyle\begin{cases}
  % $\displaystyle\aligned
  % \begin{cases}
}{
  %   \end{cases}
  % \endaligned$
  \end{cases}$$
  \par\vspace{-2ex}% adjust
  \renewcommand{\\}{\mylb}
}

% https://tex.stackexchange.com/a/228609/308105 this can't work
%\let\CondensedNewline\vspace{0.5em}
% https://stackoverflow.com/q/43821452/21294350 not work
% \newcommand{\CondenseNewline}{\newline[-1em]}

% https://tex.stackexchange.com/questions/701531/how-to-tune-the-multiline-equation-with-the-self-defined-indentation?noredirect=1#comment1744479_701531
\newcommand{\NoIndentEquationLine}[1]{%
\hspace{-5pt}#1&&\CondensedNewline%
}
% https://tex.stackexchange.com/a/451651/308105
\newcommand{\mywrongitem}{\itemsep0em \addtocounter{todolisti}{1}\item}
\newcommand{\myrightitem}{\itemsep0em \addtocounter{todolisti}{1}\correctanswer}

% must have one blank line between it and the "\end{algorithm}"
\newcommand{\ecc}[1]{%
    see the ans:%
    \begin{itemize}[noitemsep]%
        #1%
    \end{itemize}
}

\newcommand{\ProcTargetName}{test}
\newcommand{\NormalProcTargetName}{test}
\newcommand{\CapProcTargetName}{\capitalisewords{\ProcTargetName}}
\newcommand{\AlgorithmRef}{}
% https://tex.stackexchange.com/a/100930/308105
\newcommand{\CurTodolistToplevelIndex}{\number\numexpr\value{todolisti}\relax}
% \renewcommand{\CurTodolistToplevelIndex}{\number\numexpr\value{todolisti}\relax}

% use one newcommand to implement 2 \newcommand otherwise the latter one can't reuse the former's renewcommand https://tex.stackexchange.com/a/259292/308105
% test with \textbf this is the \capitalisewords problem.
\newcommand{\ModProcName}[1]{
    \renewcommand{\ProcTargetName}{\textit{#1}}
    \renewcommand{\NormalProcTargetName}{#1}
    % here should not have maths codes with space inside "$(x, y, z)$ with $(y, z, x)$" which will be ambiguous.
    \renewcommand{\CapProcTargetName}{\capitalisewords{#1}.}
    
    % \def{\ProcTargetName}{\textit{#1}}

    % \def can be nested but it is no use maybe for \capitalisewords https://tex.stackexchange.com/a/318/308105 
    % \def\NormalProcTargetName{#1}
    % \def\CapProcTargetName{\capitalisewords{\NormalProcTargetName}.}
    
    % https://tex.stackexchange.com/a/70153/308105
    \renewcommand{\AlgorithmRef}{\text{ See }\hyperref[alg:\CurTodolistToplevelIndex]{the pseudocode}}
}

\SetKwComment{Comment}{$\{$ }{ $\}$}
% \SetKwComment{tcc}{/*}{*/}
\newcommand{\mycmt}[1]{
    \{#1\}
    % \Comment{\(#1\)}
}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
% https://tex.stackexchange.com/a/302537/308105 or https://tex.stackexchange.com/a/271771/308105 which uses something like \upshape https://tug.org/pracjourn/2006-1/schmidt/schmidt.pdf
% all default formats https://tex.stackexchange.com/a/623663/308105
\SetProgSty{textnormal}

% change for all https://tex.stackexchange.com/a/279202/308105
% \AtBeginEnvironment{algorithm}{\let\textnormal\ttfamily}

% https://stackoverflow.com/a/2212644/21294350
\SetKwProg{proc}{procedure}{\vspace{-5pt}}{}
% 
\newcommand{\myproc}[2]{\proc{\normalfont#1}{#2}}
\SetKwFor{While}{while (}{)}{}
\SetKwFor{For}{for }{}{}
\SetKw{Continue}{continue}
\SetKw{Break}{break}
\SetKw{And}{and}
\newcommand{\SepAnd}{\;\And\;}
% \SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{\vspace{4pt}}
% https://tex.stackexchange.com/a/47353/308105
\let\oldelse\Else
\renewcommand{\Else}[1]{\oldelse{#1\vspace{4pt}}}
\newcommand{\ForRange}[4]{%
    % https://www.overleaf.com/learn/latex/Spacing_in_math_mode
    \For{#1\,\(\coloneqq#2\;\)\KwTo \(#3\)}{ #4}
}
\DontPrintSemicolon
% \renewcommand{\Return}[1]{\vspace{4pt}\KwRet{#1}}

% https://tex.stackexchange.com/a/639572/308105
% left aligned https://tex.stackexchange.com/a/145660/08105
% \newenvironment{AlignNoSpacing}{
%     \vspace{-15pt}
%     \begin{flalign*}
% }{
%     \end{flalign*}
%     \vspace{-25pt}
% }

\newenvironment{absolutelynopagebreak}
  {\par\nobreak\vfil\penalty0\vfilneg
   \vtop\bgroup}
  {\par\xdef\tpd{\the\prevdepth}\egroup
   \prevdepth=\tpd}

\begin{document}

\setlength{\parindent}{20pt}
\section{TODO}
\subsection{use codes to check the following exercises}
\begin{itemize}
    \item 3.1-28,46,65
\end{itemize}
\section{Predefined Rules}
\begin{enumerate}
    \item If the following item has: \\
          \ecc{\item }
          Then probably this item has errors corrected by the ans(wer).

          % not use verbatim* which contains visible whitespaces as short squat "u"s https://tex.stackexchange.com/a/448105/308105
          % https://tex.stackexchange.com/a/107657/308105
    \item for the \verb|\begin{align*}| and \verb|\begin{cases*}|, I \sout{use the same format as the book p206 shows} made them condensed to be better viewed on one page together.
\end{enumerate}
\section{section 3.1}

% \texttt{\begin{align*} and \begin{cases*}}

% https://tex.stackexchange.com/a/64476/308105
\setlength{\textfloatsep}{0pt}% Remove \textfloatsep
\setlength{\intextsep}{4pt}% Remove \textfloatsep
% https://www.overleaf.com/learn/latex/Font_sizes%2C_families%2C_and_styles#Reference_guide
\begin{large}
    14 skipped
\end{large}

\begin{todolist}[itemsep=0pt,parsep=0pt,start=3]
    \ModProcName{largest difference}
    % \ProgSty{text}\\
    \myrightitem \CapProcTargetName \AlgorithmRef
    % \CurTodolistToplevelIndex
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($a_1, a_2,\ldots , a_n: \text{integers})$}{
        }
        $i\coloneqq 1\mycmt{i\text{ is the search index}}$\\
        $d\coloneqq 0\mycmt{d\text{ is the target difference}}$\\
        \While{$i\le n-1$}{
        \lIf{$d<a_{i+1}-a_i$}{$d=a_{i+1}-a_i$}
        }
        \Return{d} \Comment{test}
    \end{SpacingAlgorithm}

    \ModProcName{number of negative integers}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($a_1, a_2,\ldots , a_n: \text{integers})$}{}
        $i\coloneqq 1\mycmt{i\text{ is the search index}}$\\
        $c\coloneqq 0\mycmt{c\text{ is the number of negative integers}}$\\
        \While{$i\le n$}{
            \lIf{$a_i<0$}{$c=c+1$}
        }
        \Return{c}
    \end{SpacingAlgorithm}

    see the ans:
    \begin{itemize}[noitemsep]
        \item here the step size of $i$ is not explicitly shown.
    \end{itemize}

    \ModProcName{location of the largest even integer}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($a_1, a_2,\ldots , a_n: \text{integers})$}{}
        $c\coloneqq 1\mycmt{c\text{ is the location index}}$\\
        $find\_even\coloneqq 0$\mycmt{$find\_even$ \text{ tracks whether even number exists}}\\
        \ForRange{i}{1}{n}{
            \lIf{$(a_i\%2==0$\text{ \normalfont and }$a_c<a_i)$}{$c=i$}
        }
        \Return{$find\_even$}
    \end{SpacingAlgorithm}

    \ecc{
        \item here should initialize the comparison with $-\infty$
        \item $find\_even$ isn't assigned value in the loop
    }

    \ModProcName{compute $x^n$}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($x$: real number, $n$: an integer)}{}
        $c\coloneqq 1\mycmt{c\text{ is the target product}}$\\
        \If{$n\ge 0$}{
            \ForRange{i}{1}{n}{
                $c=c*\cdot x$
            }
        }
        \Else{
            $n=-n$\\
            use this new $n$ to calculate\\
        }
        \Return{$c$}
    \end{SpacingAlgorithm}

    \ecc{
        \item use the absolute to combine the 2 cases
        \item the above lack the reciprocal for the negative case.
    }

    \ModProcName{replaces the triple $(x,y,z)$ with $(y,z,x)$}
    \myrightitem \CapProcTargetName \AlgorithmRef\\
    Here obviously at least 3, but this will lose one variable when assigning, so one extra to save this lost one.
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($(x, y, z)$: target tuple)}{}
        $c\coloneqq 0\mycmt{c\text{ is the tmp variable}}$
        % https://tex.stackexchange.com/a/259088/308105
        % \begin{shiftedflalign*}
        %   \NoIndentEquationLine{c=x}
        %   \NoIndentEquationLine{x=y}
        %   \NoIndentEquationLine{c=x}
        %   \NoIndentEquationLine{c=x}
        % \end{shiftedflalign*}

        \begin{shiftedalign*}
            c=x\CondensedNewline
            x=y\CondensedNewline
            y=z\CondensedNewline
            z=c\CondensedNewline
        \end{shiftedalign*}

        \Return{$(x,y,z)$}
    \end{SpacingAlgorithm}
    \addtocounter{todolisti}{2}
    \ModProcName{smallest integer in a finite sequence}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($a_1, a_2,\ldots , a_n: \text{the sequence}$)}{}
        $c\coloneqq \infty\mycmt{c\text{ is the target number}}$\\
        \ForRange{i}{1}{n}{
            \If{$c>a_i$}{
                $c=a_i$
            }
        }

        \Return{$c$}
    \end{SpacingAlgorithm}

    \ecc{
        \item $c=a_1$ is duplicate.
    }

    % \newpage
    \ModProcName{the last occurrence of the smallest element }
    \myrightitem \CapProcTargetName \AlgorithmRef\\
    This is similar to 16
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($a_1, a_2,\ldots , a_n: \text{the sequence}$)}{}
        $c\coloneqq a_1\mycmt{c\text{ is the target number}}$\\
        $l\coloneqq 1\mycmt{l\text{ is the target number index}}$\\
        \ForRange{i}{2}{n}{
            \If{$c\ge a_i$}{
                \vspace{4pt}
                $c=a_i$\\
                $l=i$
                \vspace{4pt}
            }
        }

        \Return{$l$}
    \end{SpacingAlgorithm}

    \ModProcName{ the largest and the smallest integers}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($a_1, a_2,\ldots , a_n: \text{the sequence}$)}{}
        $c\coloneqq a_1\mycmt{c\text{ is the target smallest number}}$\\
        $l\coloneqq a_1\mycmt{l\text{ is the target largest number}}$\\
        \ForRange{i}{2}{n}{
            \lIf{$c\ge a_i$}{
                $c=a_i$
            }
            \lIf{$l\le a_i$}{
                $l=a_i$
            }
        }

        \Return{$c,l$}
    \end{SpacingAlgorithm}

    \ecc{
        \item different from 18, here we don't need to track \textbf{equal} condition.
    }

    \ModProcName{ the longest word in an English sentence}
    \myrightitem \CapProcTargetName \AlgorithmRef
    % \clearpage
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($a_1, a_2,\ldots , a_n: \text{symbols}$)}{}
        $c\coloneqq 0\mycmt{c\text{ is the track length}}$\\
        $len\coloneqq 0\mycmt{len\text{ is the max length}}$\\
        $word\coloneqq blank\mycmt{word\text{ is the finded word}}$\\
        \ForRange{i}{1}{n}{
        \lIf{$a_i\text{ is a letter}$}{
            $c=c+1$
        }
        \ElseIf{$a_i\text{ is a blank}$}{
        $c=0$\\
        \If{$len<c$}{
        $len=c$\\
        $word\text{ is }substr(a_{i-len}:a_{i-1})$
        }
        }
        \lElse{
            error
        }
        }

        \Return{$word$}
    \end{SpacingAlgorithm}

    Here I use $substr$ which is similar to one predefined function in C, like \href{https://stackoverflow.com/a/4214350/21294350}{this} or others, to replace the ans $word\coloneqq\lambda\ldots word\coloneqq concatenation\ldots$\\
    Also, $length\coloneqq0$ is implied in the above $c=0$.\\
    The ans uses $\lambda$ to represent empty string as book p189 shows.
    \ModProcName{ whether a function is one-to-one}
    \mywrongitem \CapProcTargetName \AlgorithmRef\\
    \ecc{
        \item lack the func parameter
        \item My original thoughts are that we put all values mapped from the domain in one new set, and check whether duplicate conditions occur for each mapped value by \textbf{traversing} the list for the same value with the current calculated one. Obviously, this has the much higher complexity.\\
        The ans just use the $hit$ to make $one\_one$ false when accessed twice, avoiding the traverse.
    }
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($\{a_1, a_2,\ldots , a_n\}: \text{function domain},\{b_1, b_2,\ldots , b_n\}: \text{function codomain}$)}{}
    \end{SpacingAlgorithm}
    \ModProcName{ terminating Algorithm 3 if $x=a_m$}
    \mywrongitem \CapProcTargetName\\
    add $\text{if }x==a_m\text{ then }find=1;location=i;break$ before the 1st if block, \\
    then $\text{if }find==1\text{ then }return\ldots$ before the 2nd if block\\
    \ecc{
        \item the ans modified the action when $x<a_m$, this speeds up more.
    }
    \ModProcName{four sublists}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($\{a_1, a_2,\ldots , a_n\}: \text{a list},x:\text{ the target element}$)}{}
        $c_i\coloneqq 1\mycmt{c\text{ is the }i\text{th split point}}$\\
        $i\coloneqq 1,j\coloneqq n\mycmt{j,i\text{ is the tmp index}}$\\
        $location\coloneqq 0\mycmt{location\text{ is the target index, which is inited ``not found''}}$\\
        \While{$i<j$}{
            $c_1=i+\lfloor\frac{j-i}{4}\rfloor$\\
            $c_2=i+\lfloor\frac{j-i}{2}\rfloor$\\
            $c_3=i+\lfloor\frac{(j-i)*3}{4}\rfloor$\\
            \lIf{$x\le a_{c_1}$}{
                $j=c_1$
            }
            \ElseIf{$x\le a_{c_2}$}{
                $i=c_1$\\
                $j=c_2$\\
            }\ElseIf{$x\le a_{c_3}$}{
                $i=c_2$\\
                $j=c_3$
            }\lElse{
                $i=c_3$
            }
        }
        \lIf{$x==a_j$}{
            $location=j$
        }
        \Return{$location$}
    \end{SpacingAlgorithm}

    \ecc{
        \item the ans compares with the middle first, and then to the left or right which avoids some comparison overheads.
        \item also when $x>a_{c_1}$, we should let $i=c_1+1$ to avoid the duplicate future comparison.
        \item TODO the ans seems to have one error because $\lfloor\frac{j+i}{4}\rfloor>i$ doesn't always hold.
    }
    \clearpage

    \ModProcName{four sublists corrected}
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex_corrected}
        \myproc{\ProcTargetName($\{a_1, a_2,\ldots , a_n\}: \text{a list},x:\text{ the target element}$)}{}
        $c_i\coloneqq 1\mycmt{c\text{ is the }i\text{th split point}}$\\
        $i\coloneqq 1,j\coloneqq n\mycmt{j,i\text{ is the tmp index}}$\\
        $location\coloneqq 0\mycmt{location\text{ is the target index, which is inited ``not found''}}$\\
        \While{$i<j$}{
            $c_1=i+\lfloor\frac{j-i}{4}\rfloor$\\
            $c_2=i+\lfloor\frac{j-i}{2}\rfloor$\\
            $c_3=i+\lfloor\frac{(j-i)*3}{4}\rfloor$\\
            \If{$x\le a_{c_2}$}{
                \lIf{$x\le a_{c_1}$}{
                    $j=c_1$
                }\Else{
                    $i=c_1+1$\\
                    $j=c_2$\\
                }
            }
            \ElseIf{$x\le a_{c_3}$}{
                $i=c_2+1$\\
                $j=c_3$
            }\lElse{
                $i=c_3+1$
            }
        }
        \lIf{$x==a_j$}{
            $location=j$
        }
        \Return{$location$}
    \end{SpacingAlgorithm}


    \begin{itemize}
        \item Here I prove $i>j$ when out of the \textbf{while} loop is impossible.\\
              $\text{let }j-i=4n+k,k=0\sim 3$
              \begin{CondensedAlign}
                  c_1 & =n      \\
                  c_2 & =
                  \begin{cases*}
                      2n,   & k=0,1 \\
                      2n+1, & k=2,3
                  \end{cases*}\\
                  c_3 & =
                  \begin{cases*}
                      3n,   & k=0,1 \\
                      3n+1, & k=2   \\
                      3n+2, & k=3
                  \end{cases*}
              \end{CondensedAlign}
              To let $i>j$, here assume $i=0$
              although it is impossible based on the positive index assumption,
              but $c_i$ is only based on $j-i$, so it is ok to let $i=0$.
              % https://tex.stackexchange.com/a/203059/308105 here \begin{align*}
              % \begin{equation*}
              %     \begin{aligned}
              %     \end{aligned}
              % \end{equation*}

              % here cases* has no & available. https://tex.stackexchange.com/q/124751/308105

              %   $\begin{cases}
              \begin{CondensedCases}
                  1. & j=c_1,i=0\Rightarrow 0>n\text{ \textbf{impossible}}                                                                          \\
                  2. & j=c_2,i=c_1+1\Rightarrow \text{only }n+1>2n\text{ is possible}
                  \Rightarrow n=0\xRightarrow{i<j}i=0,j=1                                                                                           \\
                  & \Rightarrow x\le (a_{c_2}=a_0)\wedge x>(a_{c_1}=a_0)\text{ \textbf{impossible}}                                              \\
                  3. & j=c_3,i=c_2+1                                                                                                                \\
                  & \Rightarrow\begin{cases}
                      (k=0\text{ or }1) & 2n+1>3n\text{, here } x>(a_{c_2}=a_{c_3})(x>a_0)\text{.}              \\
                                        & \text{so }i=c_3+1=1\text{ \textbf{impossible} here}                   \\
                      (k=2)             & \text{\textbf{impossible} similarly to the above }2n+2>3n+1,i=c_3+1=2 \\
                      (k=3)             & 2n+2>3n+2\text{ trivially \textbf{impossible}}
                  \end{cases}                     \\
                  4. & i=c_3+1,j=4n+k\;\hcancel{\Rightarrow 3n+3>4n+3,\text{ \textbf{impossible}.}}                                                 \\
                  & \Rightarrow 3n+k-1+1>4n+k\text{ \textbf{impossible}.}\text{ only } 3n+k+1>4n+k\text{ is possible}                            \\
                  & \Rightarrow k=0,n=0,\text{originally }j-i=4n+k=0(\text{\textbf{also impossible} because \textbf{while} block condition }i<j)
                  %   \end{cases}$
              \end{CondensedCases}
              \newcommand{\EndingTextQED}{\(\quad\blacksquare\)}
              Based on the above, if $i<j$ into the while block,
              then in the next iteration of the while loop, $i>j$ is impossible.\EndingTextQED
        \item Prove the cases excluded by \(i<j-2\) can be contained above \textbf{correctly}.\\
              The ans shows \(i<j-2\) which excludes the following cases:
              \begin{CondensedCases}
                  i=j-1\Rightarrow c_{1\sim 3}=i&\text{then either } x>a_i,i=j
                  \text{ which excludes }a_i\\
                  &\text{or }x\le a_i,j=i\text{ which excludes }a_j\\
                  i=j-2\Rightarrow c_1=i,c_{2,3}=i+1&\text{then}
                  \begin{cases}
                      x\le a_i         & \Rightarrow j=i\text{ which excludes }a_{i+1\sim2}       \\
                      a_i<x\le a_{i+1} & \Rightarrow i=j=c_2=i+1\text{ which only allows }a_{i+1} \\
                      x>a_{i+1}        & \Rightarrow i=i+2=j\text{ which only allows }a_{i+2}
                  \end{cases}
              \end{CondensedCases}
              This also implies the above already proved ending state \(i=j\).\\
              \\
              \textbf{Alternatively} the above \textbf{correct} ``exclude/allow'' are implied by the above \(>\Rightarrow+1\)
              which is also \textbf{trivial} without the above detailed description.
              So \(i<j\) including the above two excluded cases \textbf{won't drop unnecessary items}. \\
              \\
              More specifically, the above excluded cases does \hypertarget{equivalence_ending}{same} as the ending assignments shown in the ans:\EndingTextQED
              \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex_ans_ending}
                  \lIf{$x=a_i$}{
                      $location=i$
                  }\lElseIf{$x=a_j$}{
                      $location=j$
                  }
                  \(\ldots\)\\
                  \Return{$location$}
              \end{SpacingAlgorithm}
        \item Prove that the ``Four Sublists Almost Same The Ans" and ``Four Sublists Corrected" do the \hypertarget{equivalence_algorithm}{equivalent} nested \textbf{if} blocks.\\
              Since the ``Four Sublists Almost Same The Ans" and ``Four Sublists Corrected" only
              differs for their \textbf{outer} \textbf{if} order and for each \(c_i\).
              \begin{enumerate}
                  \item when \(c_i\) all differ, \(x\) can be only in one case of the above four \(\Rightarrow\) these two algorithms do the same.
                  \item \(c_1=c_2\Rightarrow k=0,1\;n=0\Rightarrow c_3=c_2\) \(\Rightarrow\) Only two cases are allowed. These two algorithms do the same.
                  \item \(c_3=c_2\Rightarrow k=2\;n=0\text{ and the above}\) \(\Rightarrow\) Only three cases are allowed. Similarly same.
              \end{enumerate}
              \vspace{10pt}

              \textbf{Alternatively} to prove, we only needs to care the outer \textbf{if}, obviously
              whether \(c_i\) are same with each other, it can only choose one for the outer \textbf{if} for both algorithms,
              then since the following of them are same, so they do the same.
              \\
              \\
              \textbf{Alternatively}, the non-equivalence case is for that some condition blocks
              have something \textbf{overlap}, so the order matters to decide which one \(x\) exists in.\\
              But the above \((-\infty,c_1]\), \((c_1,c_2]\ldots\) can't overlap with each other (i.e. \((-\infty,c_1]\cap(c_1,c_2]\ldots=\varnothing\)).\\
              If some \(c_i\) are same with each other, only some ranges become \(\varnothing\), which doesn't influence non-overlap conclusion.\EndingTextQED

        \item Combined with the above, prove these two algorithms are totally equivalent.\\
              Except for the assignments of \(c_i\), when \(i<j-2\),
              the above \(\textbf{while }i<j\) and the ans \(\textbf{while }i<j-2\) does the same based on the above \hyperlink{equivalence_algorithm}{equivalence}.\\
              Then when \(j-2\le i<j\), \hyperlink{equivalence_ending}{this} shows they do same.\\
              when exiting with \(i=j\), trivially they do same.\EndingTextQED
    \end{itemize}

    \ModProcName{four sublists almost same the ans}
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex_ans}
        \myproc{\ProcTargetName($\{a_1, a_2,\ldots , a_n\}: \text{a list},x:\text{ the target element}$)}{}
        $c_i\coloneqq 1\mycmt{c\text{ is the }i\text{th split point}}$\\
        $i\coloneqq 1,j\coloneqq n\mycmt{j,i\text{ is the tmp index}}$\\
        $location\coloneqq 0\mycmt{location\text{ is the target index, which is inited ``not found''}}$\\
        \While{$i<j$}{
            $c_1=i+\lfloor\frac{j-i}{4}\rfloor$\\
            $c_2=i+\lfloor\frac{j-i}{2}\rfloor$\\
            $c_3=i+\lfloor\frac{(j-i)*3}{4}\rfloor$\\
            \If{$x> a_{c_2}$}{
                \If{$x\le a_{c_3}$}{
                    $i=c_2+1$\\
                    $j=c_3$
                }\Else{
                    $i=c_3+1$
                }
            }
            \ElseIf{$x> a_{c_3}$}{
                $i=c_1+1$\\
                $j=c_2$\\
            }\lElse{
                $j=c_1$
            }
        }
        \lIf{$x==a_j$}{
            $location=j$
        }
        \Return{$location$}
    \end{SpacingAlgorithm}
    similar to the above,
    \begin{CondensedCases}
        1. & j=c_3,i=c_2+1                                                                                                                     \\
        & \Rightarrow\begin{cases}
            (k=0\text{ or }1) & 2n+1>3n,n=0\text{, here } x>(a_{c_2}=a_0)\wedge x\le (a_{c_3}=a_0)\text{ \textbf{impossible}.} \\
            (k=2)             & \text{\textbf{impossible} similarly to the above }2n+2>3n+1,n=0,c_2=c_3=1                      \\
            (k=3)             & 2n+2>3n+2\text{ trivially \textbf{impossible}}
        \end{cases} \\
        2. & i=c_3+1,j=4n+k                                                                                                                    \\
        & \Rightarrow 3n+k-1+1>4n+k\text{ \textbf{impossible}.}\text{ only } 3n+k+1>4n+k\text{ is possible}                                 \\
        & \Rightarrow k=0,n=0,\text{originally }j-i=4n+k=0(\text{also \textbf{impossible} because \textbf{while} block condition }i<j)      \\
        3. & j=c_2,i=c_1+1\Rightarrow \text{only }n+1>2n\text{ is possible}
        \Rightarrow n=0 \xRightarrow{x>(a_{c_2}=a_{c_3}=a_0)} j=c_1\text{ \textbf{impossible}}                                                 \\
        4. & j=c_1,i=0\Rightarrow 0>n\text{ \textbf{impossible}}                                                                               \\
    \end{CondensedCases}

    \ModProcName{finds all modes appearing the maximum
        number of times}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($\{a_1, a_2,\ldots , a_n\}: \text{a list}$)}{}
        $S\coloneqq \varnothing\mycmt{S\text{ is the set of modes}}$\\
        $c\coloneqq 0\mycmt{c\text{ is the count}}$\\
        $tc\coloneqq 0\mycmt{tc\text{ is the local count}}$\\
        \ForRange{i}{1}{n}{
            $tc=0$\\
            \ForRange{j}{i+1}{n}{
                \If{$a_j=a_i$}{
                    $tc=tc+1$
                }\Else{
                    \Break
                }
            }
            $i=j-1$\Comment{ here I use C-style for loop, which will plus one when into the next iteration, so I minus one here}
            \lIf{$c<tc$}{$\text{clear }S\text{ and then append }S\text{ with }a_i$}
            \lElseIf{$c=tc$}{
                $\text{append }S\text{ with }a_i$
            }
        }
        \Return{$S$}
    \end{SpacingAlgorithm}
    \ecc{
        \item here $tc$ tracks duplicate count because it is inited to $0$ before comparing $a_{i+1}$ with $a_i$
        \item I missed the assignment $c=tc$ after $c<tc$.
    }

    \ModProcName{find the two that are
        closest}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{enumerate}[label=(\alph*)]
        \item \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
                  \myproc{\ProcTargetName($\{x_1, x_2,\ldots , x_n\}: \text{a list}$)}{}
                  $d\coloneqq 0\mycmt{d\text{ is the minimum distance}}$\\
                  \ForRange{i}{1}{n}{
                      \ForRange{j}{i+1}{n}{
                          \lIf{$d<|a_i-a_j|$}{
                              $d=|a_i-a_j|$
                          }
                      }
                  }
                  \Return{$d$}
              \end{SpacingAlgorithm}
        \item \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex_b}
                  \myproc{\ProcTargetName($\{x_1, x_2,\ldots , x_n\}: \text{a sorted non-decreasing list}$)}{}
                  $d\coloneqq 0\mycmt{d\text{ is the minimum distance}}$\\
                  \ForRange{i}{1}{n-1}{
                  \lIf{$d<a_{i+1}-a_i$}{
                  $d=a_{i+1}-a_i$
                  }
                  }
                  \Return{$d$}
              \end{SpacingAlgorithm}
    \end{enumerate}
    \ecc{
        \item the question needs the pair
        \item better initing $d\coloneqq|x_1-x_2|$ to avoid the compulsory first assignment.
        \item it finds minimum instead of maximum.
    }
    \begin{SpacingAlgorithm}{\xcapitalisewords{\NormalProcTargetName}\capitalisewords{ hinted by the ans}}{\CurTodolistToplevelIndex_a_mod}
        \myproc{\ProcTargetName($\{x_1, x_2,\ldots , x_n\}: \text{a list}$)}{}
        $d\coloneqq |x_1-x_2|\mycmt{d\text{ is the minimum distance}}$\\
        $f_1\coloneqq 1,f_2\coloneqq 2\mycmt{(f_1,f_2)\text{ is the target pair}}$\\
        \ForRange{i}{n}{3}{
            \ForRange{j}{n-1}{1}{
                \If{$d>|a_i-a_j|$}{
                    $d=|a_i-a_j|$\\
                    $f_1=i$\\
                    $f_2=j$
                }
            }
        }
        \Return{$(f_1,f_2)$}
    \end{SpacingAlgorithm}

    \ModProcName{greater than the sum of all
        previous terms}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($\{x_1, x_2,\ldots , x_n\}: \text{a list}$)}{}
        $sum\coloneqq 0\mycmt{sum\text{ is the sum of all
                    previous terms}}$\\
        $S\coloneqq \varnothing\mycmt{S\text{ is the finding term set}}$\\
        \ForRange{i}{2}{n}{
        $sum=sum+x_{i-1}$\\
        \lIf{$sum<x_i$}{
            $\text{append }x_i\text{ to }S$
        }
        }
        \Return{$S$}
    \end{SpacingAlgorithm}
    \ecc{
        \item the ans takes $a_1>0$ in account.
    }

    \addtocounter{todolisti}{3}
    \ModProcName{Adapted bubble sort}
    \myrightitem \CapProcTargetName \AlgorithmRef\\
    This is similar to the \href{https://en.wikipedia.org/wiki/Bubble_sort#Optimizing_bubble_sort}{wikipedia 1st example}
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($\{a_1, a_2,\ldots , a_n\}: \text{a list}$)}{}
        $swap\coloneqq 0\mycmt{swap\text{ is the state variable}}$\\
        \ForRange{i}{1}{n-1}{
        $swap=0$\\
        \ForRange{j}{1}{n-i}{
        \If{$a_{j+1}>a_j$}{
        \vspace{2pt}
        $swap=1$\\
        $\text{swap }a_{j+1}\text{ and }a_j$
        }
        }
        \If{$swap=0$}{
            \Break
        }
        }
    \end{SpacingAlgorithm}
    Here when $i=n-1$, nothing needs to be done.

    \addtocounter{todolisti}{3}
    \ModProcName{selection sort}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($\{a_1, a_2,\ldots , a_n\}: \text{a list}$)}{}
        $MinIndex\coloneqq 1\mycmt{MinIndex\text{ is the global minimum index}}$\\
        $min\coloneqq a_1\mycmt{min\text{ is the minimum value}}$\\
        \ForRange{i}{1}{n-1}{
        $min=a_i$\\
        \(MinIndex=i\)\\
        \ForRange{j}{i+1}{n-1}{
            \If{$a_j<min$}{
                $min=a_j$\\
                \(MinIndex=j\)
            }
        }
        \If{\(MinIndex\neq a_i\)}{
        \(\text{insert }a_{MinIndex}\text{ same as how the insertion sort inserts}\)
        }
        }
    \end{SpacingAlgorithm}
    \ecc{
        \item \(min=a_i\) ,etc ,are unnecessary.
        \item ``interchange'' is enough.\\
        The insertion used in the insertion sort is due to that it needs to keep the sublist ordered which is used in the placement search $while\; a_j > a_i$.
    }
    \addtocounter{todolisti}{-1}
    \ModProcName{linear search for the insert position}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($\{a_1, a_2,\ldots , a_n\}: \text{a sorted non-decreasing list, }x:\text{target}$)}{}
        \ForRange{i}{1}{n}{
            \If{\(x\ge a_i\)}{
                \Break
            }
        }
        \Return{\(i\)} \Comment{ this is the first index with \(x<a_i\)}
    \end{SpacingAlgorithm}
    \ecc{
        \item the ans is based on the non-increasing list, and the ans just means returning \(i\) because
        when \(i>n\), it can only be \(n+1\).
        \item \sout{it should return \(i+1\) when $i\neq n+1$ and 1 when $i=n+1$ (i.e. less than all items)}
        \item \sout{the above \textbf{break} should be \textbf{continue}.}
        \item the above should be \(x\le a_i\textbf{ then break}\) and return \(i\).\\
        Then when \(x\le a_1\), \textbf{break} after \(i=1\) \textbf{without the increment} by the \textbf{for} \(\Rightarrow\) insert at 1st location\\
        If \(x>a_n\), then the auto increment will make it insert at \((n+1)\)th location.
        \item Here we should not use \(\textbf{continue}\) because it is just what the \(\textbf{for}\) defaults to do.
        \item inserting at the \(i\)th means after the insertion, the inserted item is the \(i\)th element
        which is same as the insertion sort behavior. We can think it as \textbf{replace}.
    }
    \addtocounter{todolisti}{-1}
    \ModProcName{binary search for the insert position}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName($\{a_1, a_2,\ldots , a_n\}: \text{a sorted non-decreasing list, }x:\text{target}$)}{}
        \(s\coloneqq 1\mycmt{s\text{ is the start index}}\)\\
        \(end\coloneqq n\mycmt{end\text{ is the end index}}\)\\
        \(c\coloneqq \lfloor\frac{s+end}{2}\rfloor\mycmt{c\text{ is the comparison index}}\)\\
        \While{\(s<end\)}{
            \(c=\lfloor\frac{s+end}{2}\rfloor\)\\
            \lIf{\(x\le a_c\)}{
                \(end=c\)
            }\lElse{
                \(s=c+1\)
            }
        }
        \Return{\(s\)}
    \end{SpacingAlgorithm}
    Here to make \(s>end\), with the backwards calculation and the assumption \(s<end\), either \(s>\lfloor\frac{s+end}{2}\rfloor\) or \(\lfloor\frac{s+end}{2}\rfloor+1>end\), but both are impossible.
    So the \(s<end\) condition can be only exited when \(s=end\)\\
    \\
    Since \(end-s=2n+1\text{ or }end-s=2n\Rightarrow c=s+n=s+\lfloor\frac{end-s}{2}\rfloor\), so output \((s,s+n)\text{ or }(s+n+1,end)\).
    Their difference must be \(<n=\lfloor\frac{end-s}{2}\rfloor\). Then recursively, in the end \(end-s=1\text{ or }0\)
    because \(\lfloor\frac{end-s}{2}\rfloor\) will make all values greater than 2 to \(1\text{ or }0\). Then since \(end>s\),
    so \(end-s=1\) at the end loop before exiting.\\
    \\
    Based on the above, the sequence \(\{end-s\}\text{ must be }\ldots\to 1\to 0\)\\
    \\
    % (here use \(s'\) to denote \(s\) in the before step, this notation also applies for other variables)\\
    Then assume when exiting, state is \(k_0\) where \(s=end=t\text{ or }t+1\)\\
    Then when exited from the state \(k_{-1}\) where \((s,end)=(t,t+1)\), either enter state \((t,t)\) when \(x\le a_t\) or \((t+1,t+1)\) when \(x> a_t\)\\
    Backwards again with the \(k_{-2}\to k_{-1}\) step is one of the following:
    \begin{enumerate}
        \item \(end=t+1\Rightarrow k_{-2}:end=t+2\text{ or }t+3\), \(x\le a_{c}=a_{t+1}\) \label{item_if_3_1_46}
        \item \(s=c+1=(t-1)-1\Rightarrow x>a_c=a_{t-1}\) \label{item_else_3_1_46}
    \end{enumerate}
    Combined two bullet items with the above, return:\\
    \[
        \begin{cases}
            t   & a_{t-1}<x\le a_{t} \\
            t+1 & a_{t}<x\le a_{t+1}
        \end{cases}
    \]\\
    Then \(a_{ret-1}<x\le a_{ret}\)\\
    \sout{TODO then the ans assignment of $location+1$ when \(x\ge a_i\) at the exiting loop (i.e. \(i=s=end\)) is impossible}
    \ecc{
        \item The above conclusion \hyperref[item_if_3_1_46]{one} is \textbf{wrong} because at least for the last item \(a_n\),
        there is no corresponding \(a_{n+1}\) for comparison, so we need \(location\coloneqq i+1\text{ when }x\ge a_i\) for this special case.\\
        This is \textbf{same} as exercise 45 which also needs to \textbf{append} the list sometimes.
        \item For conclusion \hyperref[item_else_3_1_46]{two}, although for \(a_1\), \(a_0\) doesn't exist.
        But it is enough to insert \(x\) at \(a_1\) if \(x\le a_1\). So it is \textbf{right} at least for this case although invalid \(a_0\).
    }
    \addtocounter{todolisti}{3}
    \ModProcName{binary insertion sort}
    \myrightitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName(\(\{a_1, a_2,\ldots , a_n\}: \text{a list}\))}{}
        \(insert\coloneqq 0\mycmt{insert\text{ is the insertion location}}\)\\
        \(s\coloneqq 1\mycmt{s\text{ is the start index}}\)\\
        \(end\coloneqq 1\mycmt{end\text{ is the end index}}\)\\
        \(c\coloneqq \lfloor\frac{s+end}{2}\rfloor\mycmt{c\text{ is the comparison index}}\)\\
        \ForRange{i}{1}{n-1}{
        \(s=1\)\\
        \(end=i\)\\
        % binary insertion
        \While{\(s<end\)}{
            \(c=\lfloor\frac{s+end}{2}\rfloor\)\\
            % \lIf{\(x\le a_c\)}{
            \lIf{\(a_{i+1}\le a_c\)}{
                \(end=c\)
            }\lElse{
                \(s=c+1\)
            }
        }
        % \lIf{\(x>a_s\)}{\Return{\(s+1\)}}
        % \lElse{\Return{\(s\)}}
        \lIf{\(a_{i+1}>a_s\)}{\(insert=s+1\)}
        \lElse{\(insert=s\)}
        \(\text{insert }a_{i+1}\text{ at }insert\text{ location similar to
            what the original insertion sort does}\)
        }
    \end{SpacingAlgorithm}
    \addtocounter{todolisti}{-1}
    \ModProcName{insertion sort with the backwards search}
    \myrightitem \CapProcTargetName \AlgorithmRef\\
    Here assume to make the list non-decreasing.
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName(\(\{a_1, a_2,\ldots , a_n\}: \text{a list}\))}{}
        \(insert\coloneqq 0\mycmt{insert\text{ is the insertion location}}\)\\
        \ForRange{i}{2}{n}{
        % backwards linear insertion
        \ForRange{j}{i-1}{1}{
            \If{\(a_j\ge a_i\)}{
                \vspace{2pt}
                \Break
                \vspace{4pt}
            }
        }
        \(insert=i+1\)\\
        \(\text{insert }a_{i}\text{ at }insert\text{ location similar to
            what the original insertion sort does}\)
        }
    \end{SpacingAlgorithm}
    \ecc{
        \item The ans puts insertion (two assignments related with \(m\) and \(a_{i+1}=a_i\))
        inside the while loop, i.e. the inner for loop here.
    }
    \addtocounter{todolisti}{6}
    \mywrongitem TODO strict proof\\
    similar to lemma 1. Here we make lemma 2:
    \[
        \displaylines{
            \text{ here the number in the parentheses means the coin count}\cr
            \begin{aligned}
                12\;(\text{at most 4}): &
                \begin{cases}
                    12(1)=10+2*1(3)      \\
                    24(2)=10*2+4*1(6)    \\
                    36(3)=25+10+1        \\
                    48(4)=25+2*10+3*1(6) \\
                    60(5)=25*2+10(3)
                \end{cases}      \\
            \end{aligned}\cr
            10\;(\text{at most 2 same as the original})\text{. The rest are also unchanged}
        }
    \]
    then we at most 4 12-cent coins, 2 dimes, 1 penny (two will make 50 with the 12-cent).
    In sum, they are 69 cents exceeding one quarter. So not optimal.
    \addtocounter{todolisti}{3}
    \ModProcName{deferred acceptance algorithm}
    \mywrongitem \CapProcTargetName \AlgorithmRef
    \begin{SpacingAlgorithm}{\CapProcTargetName}{\CurTodolistToplevelIndex}
        \myproc{\ProcTargetName(\(\{m_{ij}|i,j\in\{1,2,3\}\}: \text{man preference list with }m_{ij}\text{ means }j\text{th woman }m_i\text{ prefers}
            ,\{w_{ji}\}:\text{similar to }\{m_{ij}\}\))}{}
        \tcc{Here we use the row-major arrays}
        \(\{r_{ji}|i,j\in\{1,2,3\}\}\coloneqq \{0,\ldots\}\)
        \Comment{\(\{r_{ji}\}\text{ is the rejection list with }r_{ji}=1\text{ meaning }j\text{th woman rejects }i\text{th man},r_{ji}=2\text{ means pending},r_{ji}=0\text{ means unmodifiedly inited}\)}
        % \hfuzz=60pt
        % Ans:"add i to the proposal list for the woman j who ranks highest on his preference list"
        \(\{p_{iq}|i\in\{1,2,3\},q>0\}\coloneqq \{m_{11},0,0,m_{21},\ldots\}\)
        \Comment{\(\{p_{iq}\}\text{ is the proposal list with }p_{ik}\text{ means the proposal woman by the }i\text{th man at the }k\text{th round}\)}
        \(k\coloneqq 1\mycmt{k\text{ is the round variable}}\)\\
        \(prefer_{j}\coloneqq 4\)
        \Comment{\(prefer_{j}\text{ is the man who the }j\text{th woman prefers in the list}r_{ji}\)\\\(\text{with the bigger num/index in the list implies less preference}\)}
        % "ends when every suitor has exactly one pending proposal"
        % "The series of rounds ends when every suitor has exactly one pending proposal." means that it is not rejected
        \While{\(\text{each row of}\{r_{ji}\}\text{ has exactly one }2\SepAnd\text{the rest are all }1\)}{
            \tcc{TODO here I think the question means all the rest are rejected when only one is pending because at the \textit{first} round \textit{always only one} pending}
            % add the pending items.
            % Ans: "mark i as not rejected", here assume that it means pending.
            \ForRange{i}{1}{3}{
                \tcc*[l]{Here \(p_{ik}\) are not already rejected ones, so just pend them without the redundant check}
                \(r_{p_{ik}i}=2\)
            }
            \ForRange{j}{1}{3}{
                % "a more appealing suitor proposes"

                % Ans: "except the man i0 who ranks highest"
                % "woman j’s proposal list is nonempty" is checked by r_{ji}=2 which is assigned by r_{p_{ik}i}=2
                \tcc{prefer variable update}
                \ForRange{i}{1}{3}{
                    \If{\(r_{ji}=2\SepAnd FindIndex(j,i)<FindIndex(j,prefer_j)\)}{
                        \tcc*[l]{\(FindIndex(j,i)\text{ returns the index of }i\text{th man in the }j
                            \text{th woman list.}\)
                            \(\text{The inited }FindIndex(j,4)=\infty\)}
                        \(prefer_j=i\)
                    }
                }
                % "is rejected in a later round if a more appealing suitor proposes in that round"
                % "rejects all proposals except that ... ranks highest ... have proposed"

                % Ans: "remove from j’s proposal list all men i except the man i0
                % ... for each such man i mark him as rejected and add j to his rejection list" Here contents before and after "and" mean the same.
                \tcc{rejection}
                \ForRange{i}{1}{3}{
                    \tcc{Here only the preferred ones can be left pending}
                    \If
                    {\(r_{ji}=2\SepAnd FindIndex(j,i)>FindIndex(j,prefer_j)\)}{
                        \(r_{ji}=1\)
                    }
                }
            }
            \(k=k+1\)\\
            \tcc{proposal reinitialization}
            % "proposes to his or her highest ranking suitee who has not already rejected"
            % Ans: "... but does not appear on his rejection list"
            \ForRange{i}{1}{3}{
                \ForRange{j}{m_{11}}{m_{13}}{
                    \If{\(r_{ji}\neq 1\)}{
                        \(p_{ik}=j\)
                    }
                }
            }
        }
        \Return{\(\{p_{i\,k-1}\}\)}
    \end{SpacingAlgorithm}
    \ecc{
        \item the ans says the assumption "the men are the suitors ..." explicitly
        \item Here I inited rejection list with one more \textbf{uninitiated} state
        \item The ans assumes \(s\) men instead of \(3\).
        \item TODO See above "because at the first round always only one pending",\\
        when "rejected men remain" is wrong, it means no "for each such man i mark
        him as rejected" is done. In turn,
        all men has their rejection list excluding the needed ones which make them won't be rejected when proposal,
        i.e. the above "all 1".
    }
    I recommend to read the \href{https://en.wikipedia.org/wiki/Gale%E2%80%93Shapley_algorithm#Algorithm}{wikipedia} instead of the book one 
    which is too abstract similar to the original question description where the applicant is the suitee.
    \begin{SpacingAlgorithm}{\xcapitalisewords{\NormalProcTargetName}\capitalisewords{ in wikipedia}}{\CurTodolistToplevelIndex_wiki}
        \myproc{\ProcTargetName(\(\{a_1, a_2,\ldots , a_n\}: \text{a list}\))}{}
        % this is trivially done above by some kinds of initialization
        Initialize \(e\in E\) and \(a\in A\) to free\\
        % when no free, i.e. no rejected, more specially no pending ones are rejected. See the above While loop condition.
        \While{\(\exists\) free employer e who has an applicant a to send an offer to}{
            % done by the above "proposal reinitialization"
            a \(\coloneqq\) first applicant on e's list to whom e has not yet sent an offer\\
            % here "pair" correspond to the above pending ones.
            \If{\(\exists \text{ some pair } (e', a)\)}{
                % done by the above "prefer variable update"
                \If{a prefers e to \(e'\)}{
                    % free means the above "rejected"
                    \(e'\) becomes free\\
                    % it is denoted as the above "pending" which is not rejected after "rejection"
                    \((e, a)\) become matched
                }
                \Else{
                    \((e, a)\) become matched
                }
            }
        }
    \end{SpacingAlgorithm}
    \begin{enumerate}
        \item "\(\exists\) \textbf{free} employer e who has an applicant a to send an offer to"
              and "e' becomes free" mean that when exiting all are not free
              where "(e, a) become matched" after "e' becomes free" corresponds to the above \(prefer_j=i\), i.e. above not rejected after \(r_{ji}=1\)
    \end{enumerate}
\end{todolist}

% \newpage
% \begin{todolist}[resume*,start=\CurTodolistToplevelIndex]
%     \mywrongitem test 3
%     \mywrongitem test 5
%     \mywrongitem test 5
%     \mywrongitem test 5
% \end{todolist}

\end{document}
